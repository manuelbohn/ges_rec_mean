---
title: "Plots and models"
output: html_document
---

1. Load packages and data file
```{r setup, include=FALSE}
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(ggpubr)
library(exactRankTests)
library(lme4)
library(langcog)
library(brms)
library(wordcloud)
library(RColorBrewer)
library(patchwork)
library(ngram)

# install.packages("bayesplot")
# if (!require("devtools")) {
#   install.packages("devtools")
# }
# devtools::install_github("stan-dev/bayesplot")

library("bayesplot")
library("rstanarm")
library("ggplot2")

##library(psychometric)
##library(multilevel)
##library(nlme)

##library(Rmisc)
##library(lattice)
##library(plyr)

## library(devtools)
## devtools::install_github("langcog/langcog")

data <- read.csv2("data_file_stimulus.csv")
data

## To Do AnfÃ¼hrung Klammer
```


2. Plots
2.1. Plots (hol versus seq) seperate for object_str, object_se, feature_str, feature_se (with: rel, irrel, ne)
```{r cars}
plot_1 <- ggplot(data = data, aes(x = condition, col = object_str)) +
  labs (x = "condition", y = "object_str") +
  geom_bar() 

plot_2 <- ggplot(data = data, aes(x = condition, col = feature_str)) +
  labs (x = "condition", y = "feature_str") +
  geom_bar() 

plot_3 <- ggplot(data = data, aes(x = condition, col = object_se)) +
  labs (x = "condition", y = "object_se") +
  geom_bar() 

plot_4 <- ggplot(data = data, aes(x = condition, col = feature_se)) +
  labs (x = "condition", y = "feature_se") +
  geom_bar() 

plot_1
plot_2
plot_3
plot_4

```


2.2. Create binary dependent variables 
```{r pressure, echo=FALSE}

## dependent variable: code 'rel' = 1 and 'irr or ne' = 0 -> enables comparison with respect to relevant answers (relevant object/feature or not) 
data_rel_not <- data %>%
  separate(stimulus_nc, c("object", "predicate"), remove = F) %>%
  mutate(object_str = ifelse(object_str == "rel", "1", "0"),
         object_str = as.numeric(as.character(object_str)),
         feature_str = ifelse(feature_str == "rel", "1", "0"),
         feature_str = as.numeric(as.character(feature_str)),
         object_se = ifelse(object_se == "rel", "1", "0"),
         object_se = as.numeric(as.character(object_se)),
         feature_se = ifelse(feature_se == "rel", "1", "0"),
         feature_se = as.numeric(as.character(feature_se)))

## dependent variable: code 'rel + irrel' = 1 and 'ne' = 0 -> enables comparison with respect to existence of an answer (does an object/feature exist or not)
data_ex_ne <- data %>%
  separate(stimulus_nc, c("object", "predicate"), remove = F) %>%
  mutate(object_str = ifelse(object_str == "ne", "0", "1"),
         object_str = as.numeric(as.character(object_str)),
         feature_str = ifelse(feature_str == "ne", "0", "1"),
         feature_str = as.numeric(as.character(feature_str)),
         object_se = ifelse(object_se == "ne", "0", "1"),
         object_se = as.numeric(as.character(object_se)),
         feature_se = ifelse(feature_se == "ne", "0", "1"),
         feature_se = as.numeric(as.character(feature_se)))
``` 



2.3. Plots - comparing hol versus seq seperate for feature and objects
```{r}
## dependent variable: 'rel' = 1 or 'irr + ne' = 0 
plot1 <- data_rel_not%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc, -object, -predicate, -responses)

plot2 <- plot1%>%
  group_by(condition, dimension)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot1, aes(x = dimension, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot2,aes(x = dimension, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Picture")+
  scale_y_continuous(name = "Relevance (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()


## dependent variable: 'rel + irrel' = 1 or 'ne' = 0
plot3 <- data_ex_ne%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc,-object, -predicate, -responses)

plot4 <- plot3%>%
  group_by(condition, dimension)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot3, aes(x = dimension, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot4,aes(x = dimension, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Picture")+
  scale_y_continuous(name = "Existence (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()
```


2.4. Plots - comparing hol versus seq seperate for each category (object: mov, num, size) and (feature: animal, object)
```{r}
### dependent variable: 'rel' = 1 or 'irr + ne' = 0

## object_str
plot1 <- data_rel_not%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc, -object, -predicate, -responses) %>%
  filter (dimension == "object_str")

plot2 <- plot1%>%
  group_by(condition, object)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot1, aes(x = object, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot2,aes(x = object, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Object")+
  scale_y_continuous(name = "Relevance (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()

## feature_str
plot1 <- data_rel_not%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc, -object, -predicate, -responses) %>%
  filter (dimension == "feature_str")

plot2 <- plot1%>%
  group_by(condition, predicate)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot1, aes(x = predicate, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot2,aes(x = predicate, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Feature")+
  scale_y_continuous(name = "Relevance (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()


### dependent variable: 'rel + irrel' = 1 or 'ne' = 0

## object_str
plot1 <- data_ex_ne%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc, -object, -predicate, -responses) %>%
  filter (dimension == "object_str")

plot2 <- plot1%>%
  group_by(condition, object)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot1, aes(x = object, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot2,aes(x = object, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Object")+
  scale_y_continuous(name = "Existence (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()

## feature_str
plot1 <- data_ex_ne%>%
  select(-X, - repetitions, -X.1)%>%
  gather(dimension, correct,-condition, -id, -stimulus_nc, -object, -predicate, -responses) %>%
  filter (dimension == "feature_str")

plot2 <- plot1%>%
  group_by(condition, predicate)%>%
  multi_boot_standard(col = "correct")

ggplot() +
  geom_jitter(data = plot1, aes(x = predicate, y = correct, col = condition), position = position_jitterdodge(jitter.width = .2, jitter.height = 0.05,dodge.width = 0.5), alpha = .3)+
  geom_pointrange(data = plot2,aes(x = predicate, y = mean, col = condition, ymin = ci_lower, ymax = ci_upper), 
                  position = position_dodge(width = .5), size = 0.6, pch = 5) +
  guides(alpha = F)+
  labs(x="Feature")+
  scale_y_continuous(name = "Existence (Proportion correct)", limits = c(-0.05,1.05))+
  theme_few() + 
  scale_colour_solarized()

```



3. Calculate baysian models

3.1. Data files for models
```{r}
## Number of words per response
data_wordcount <- data %>%
  separate(stimulus_nc, c("object", "predicate"), remove = F) %>%
  mutate(responses = ifelse(responses == "", NA, as.character(responses)))%>%
  group_by(id, object, predicate, condition, responses)%>%
  mutate(words = wordcount(responses)) %>%
  ungroup() %>%
  mutate(property = ifelse(predicate == "jump" | predicate == "run", "movement",
                           ifelse(predicate == "big" | predicate == "small", "size","number")),
         class = ifelse(object == "ball" | object == "bike" | object == "comb" | object == "bike" | object == "fork" | object == "hammer", "object","animal"))


## Existence of object AND feature in respone
data_of_structure <- data %>%
  separate(stimulus_nc, c("object", "predicate"), remove = F) %>%
  mutate(object_str = ifelse(object_str == "ne", "0", "1"),
         object_str = as.numeric(as.character(object_str)),
         feature_str = ifelse(feature_str == "ne", "0", "1"),
         feature_str = as.numeric(as.character(feature_str)),
         obj_fea = ifelse(object_str == 1 & feature_str == 1, "1", "0"),
         property = ifelse(predicate == "jump" | predicate == "run", "movement",
                           ifelse(predicate == "big" | predicate == "small", "size","number")),
         class = ifelse(object == "ball" | object == "bike" | object == "comb" | object == "bike" | object == "fork" | object == "hammer", "object","animal"),
         obj_fea = as.numeric(as.character(obj_fea)))

## inhaltlich relevant (erst Ã¼berprÃ¼fen wie viele FÃ¤lle) 
hist(data_of_structure$obj_fea)
## --> genÃ¼gend
  
## Feature in response is relevant
data_fea_content <- data %>%
  separate(stimulus_nc, c("object", "predicate"), remove = F) %>%
  mutate (feature_str = ifelse(feature_str == "rel", "1", "0"),
          feature_str = as.numeric(as.character(feature_str))) %>%
  mutate(property = ifelse(predicate == "jump" | predicate == "run", "movement",
                           ifelse(predicate == "big" | predicate == "small", "size","number")),
         class = ifelse(object == "ball" | object == "bike" | object == "comb" | object == "bike" | object == "fork" | object == "hammer", "object","animal"))

```




3.2. dependent variable 'length' (hier keine binÃ¤re Codierung) -> Poisson Verteilung
```{r}
## https://www.rdocumentation.org/packages/brms/versions/2.12.0/topics/brmsfamily
## Daten Plotten als Histogramm, dann:
hist(data_wordcount$words)
## --> Poisson Verteilung und negative binomial (nur condition model)


# m1_l_p

m1_l_p <- brm(words ~ condition * property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = poisson(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m1_l_p.rds")

m1_l_p <- readRDS("../saves/m1_l_p.rds")


# m2_l_p

m2_l_p <- brm(words ~ condition + property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = poisson(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m2_l_p.rds")

m2_l_p <- readRDS("../saves/m2_l_p.rds")


# m3_l_p

m3_l_p <- brm(words ~ property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = poisson(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m3_l_p.rds")

m3_l_p <- readRDS("../saves/m3_l_p.rds")


# m4_l_p (condition als einziger PrÃ¤dikter, Rest random effects) 
m4_l_p <- brm(words ~ condition + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = poisson(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m4_l_p.rds")

m4_l_p <- readRDS("../saves/m4_l_p.rds")


## m5_l_p (Baseline Modell, auch in Modellvergleich)
m5_l_p <- brm(words ~ 1 + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = poisson(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m5_l_p.rds")

m5_l_p <- readRDS("../saves/m5_l_p.rds")


# model comparison 
loo_compare(m1_l_p, m2_l_p, m3_l_p, m4_l_p, m5_l_p, criterion = "waic")%>%
  as.data.frame() %>%
  tibble::rownames_to_column("Predictors")%>%
  mutate(
    Predictors = recode(Predictors, 
                   m1_l_p = "condition by property", 
                   m2_l_p = "condition + property",
                   m3_l_p = "property",
                   m4_l_p = "condition",
                   m5_l_p = "baseline"),
    weight = exp(elpd_waic) / sum(exp(elpd_waic)),
    weight = round(weight, 2),
    WAIC = round(waic, 2),
    SE = round(se_waic,2))%>%
  select(Predictors, WAIC, SE, weight)

## data overfitted
# best model: condition (lowest WAIC score)
```




3.2. dependent variable 'length' --> negative binomial  negbinomial
```{r}
# m1_l_nb

m1_l_nb <- brm(words ~ condition * property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = negbinomial(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m1_l_nb.rds")

m1_l_nb <- readRDS("../saves/m1_l_nb.rds")


# m2_l_nb

m2_l_nb <- brm(words ~ condition + property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = negbinomial(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m2_l_nb.rds")

m2_l_nb <- readRDS("../saves/m2_l_nb.rds")


# m3_l_nb

m3_l_nb <- brm(words ~ property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = negbinomial(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m3_l_nb.rds")

m3_l_nb <- readRDS("../saves/m3_l_nb.rds")

## m4_l_nb
m4_l_nb <- brm(words ~ condition + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = negbinomial(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m4_l_nb.rds")

m4_l_nb <- readRDS("../saves/m4_l_nb.rds")


## m5_l_nb
m5_l_nb <- brm(words ~ 1 + (condition * property | id) + (condition | stimulus_nc),
                    data = data_wordcount, family = negbinomial(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m5_l_nb.rds")

m5_l_nb <- readRDS("../saves/m5_l_nb.rds")


# model comparison 
loo_compare(m1_l_nb, m2_l_nb, m3_l_nb, m4_l_nb, m5_l_nb, criterion = "waic")%>%
  as.data.frame() %>%
  tibble::rownames_to_column("Predictors")%>%
  mutate(
    Predictors = recode(Predictors, 
                   m1_l_nb = "condition by property", 
                   m2_l_nb = "condition + property",
                   m3_l_nb = "property",
                   m4_l_nb = "condition",
                   m5_l_nb = "baseline"),
    weight = exp(elpd_waic) / sum(exp(elpd_waic)),
    weight = round(weight, 2),
    WAIC = round(waic, 2),
    SE = round(se_waic,2))%>%
  select(Predictors, WAIC, SE, weight)

## best model: condition only


```




3.2. DV 'Object-feature structure'
```{r}
# Bayesian model object-feature structure

# m1_of 

m1_of <- brm(obj_fea ~ condition * property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_of_structure, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m1_of.rds")

m1_of <- readRDS("../saves/m1_of.rds")

## m2_of 

m2_of <- brm(obj_fea ~ condition + property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_of_structure, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m2_of.rds")

m2_of <- readRDS("../saves/m2_of.rds")


# m3_of 

m3_of <- brm(obj_fea ~ property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_of_structure, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m3_of.rds")

m3_of <- readRDS("../saves/m3_of.rds")


# m4_of 

m4_of <- brm(obj_fea ~ condition + (condition * property | id) + (condition | stimulus_nc),
                    data = data_of_structure, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m4_of.rds")

m4_of <- readRDS("../saves/m4_of.rds")


# m5_of 

m5_of <- brm(obj_fea ~ 1 + (condition * property | id) + (condition | stimulus_nc),
                    data = data_of_structure, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m5_of.rds")

m5_of <- readRDS("../saves/m5_of.rds")

# model comparison 
loo_compare(m1_of, m2_of, m3_of, m4_of, m5_of, criterion = "waic")%>%
  as.data.frame() %>%
  tibble::rownames_to_column("Predictors")%>%
  mutate(
    Predictors = recode(Predictors, 
                   m1_of = "condition by property", 
                   m2_of = "condition + property",
                   m3_of = "property",
                   m4_of = "condition",
                   m5_of = "baseline"),
    weight = exp(elpd_waic) / sum(exp(elpd_waic)),
    weight = round(weight, 2),
    WAIC = round(waic, 2),
    SE = round(se_waic,2))%>%
  select(Predictors, WAIC, SE, weight)



# best model: baseline



## https://mc-stan.org/bayesplot/ Bayesplots for ggplot
# m1_of

# fit <- stan_glm(m1_of, data = data_of_structure)
# posterior <- as.matrix(fit)

# plot_title <- ggtitle("Posterior distributions",
#                      "with medians and 80% intervals")
# mcmc_areas(posterior,
#           pars = c("hol", "seq"),
#           prob = 0.8) + plot_title

```


3.3. DV 'Feature content'
```{r}
# m1_fc 

m1_fc <- brm(feature_str ~ condition * property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_fea_content, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m1_fc.rds")

m1_fc <- readRDS("../saves/m1_fc.rds")


# m2_fc 

m2_fc <- brm(feature_str ~ condition + property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_fea_content, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m2_fc.rds")

m2_fc <- readRDS("../saves/m2_fc.rds")


# m3_fc 

m3_fc <- brm(feature_str ~ property + (condition * property | id) + (condition | stimulus_nc),
                    data = data_fea_content, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m3_fc.rds")

m3_fc <- readRDS("../saves/m3_fc.rds")


# m4_fc 

m4_fc <- brm(feature_str ~ condition + (condition * property | id) + (condition | stimulus_nc),
                    data = data_fea_content, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m4_fc.rds")

m4_fc <- readRDS("../saves/m4_fc.rds")


# m5_fc 

m5_fc <- brm(feature_str ~ 1 + (condition * property | id) + (condition | stimulus_nc),
                    data = data_fea_content, family = bernoulli(),
          control = list(adapt_delta = 0.99, max_treedepth = 20),
          sample_prior = F,
          cores = 4,
          chains = 4,
          inits = 0,
          iter = 5000)%>%
  add_criterion("waic")%>%
  saveRDS(.,"../saves/m5_fc.rds")

m5_fc <- readRDS("../saves/m5_fc.rds")


# model comparison 
loo_compare(m1_fc, m2_fc, m3_fc, m4_fc, m5_fc, criterion = "waic")%>%
  as.data.frame() %>%
  tibble::rownames_to_column("Predictors")%>%
  mutate(
    Predictors = recode(Predictors, 
                   m1_fc = "condition by property", 
                   m2_fc = "condition + property",
                   m3_fc = "property",
                   m4_fc = "condition",
                   m5_fc = "baseline"),
    weight = exp(elpd_waic) / sum(exp(elpd_waic)),
    weight = round(weight, 2),
    WAIC = round(waic, 2),
    SE = round(se_waic,2))%>%
  select(Predictors, WAIC, SE, weight)


## best model: condition by property
```



4. Word Clouds
4.1. Create data file for word clouds
```{r}
data_file <- read.csv2("data_file.csv")%>%
  select(-X) 

data_words <- read.csv2("Words_data_codiert.csv")%>%
  select(-X) 

data_wordcloud <- data_file %>%
  left_join(data_words) %>%
  mutate (value = tolower(value))


## TO DO: Rechtschreibfehler korrigieren

### ?? nachdem Kleinschreibung geÃ¤ndert wurde mÃ¼ssten die WÃ¶rter, die jetzt gleich sind, als ein value notiert werden (in der Zeile muss doe freq der beiden WÃ¶rter addiert werden und nur ein type (sollten identisch sein) verwendet werden)
data_words <- read.csv2("Words_data_codiert.csv")%>%
  select(-X) %>%
  mutate (value = tolower(value)) %>%
  group_by(value) %>%
  summarise(freq = n(freq), type = first(type))

  
  ## 439 Zeilen  

## vor HÃ¤ufigkeiten nur Kleinschreibung!! (tolower)
## Rechtschreibfehler korrigieren (in Excel)  
```


Wordclouds for each stimulus (objects)
```{r}
## ball
ball_hol <- data_wordcloud %>%
  filter(type == "object", object == "ball", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = ball_hol$value, freq = ball_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

ball_seq <- data_wordcloud %>%
  filter(type == "object", object == "ball", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = ball_seq$value, freq = ball_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


## bike
bike_hol <- data_wordcloud %>%
  filter(type == "object", object == "bike", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = bike_hol$value, freq = bike_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

bike_seq <- data_wordcloud %>%
  filter(type == "object", object == "bike", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = bike_seq$value, freq = bike_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

# cat
cat_hol <- data_wordcloud %>%
  filter(type == "object", object == "cat", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = cat_hol$value, freq = cat_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

cat_seq <- data_wordcloud %>%
  filter(type == "object", object == "cat", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = cat_seq$value, freq = cat_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## comb
comb_hol <- data_wordcloud %>%
  filter(type == "object", object == "comb", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = comb_hol$value, freq = comb_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

comb_seq <- data_wordcloud %>%
  filter(type == "object", object == "comb", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = comb_seq$value, freq = comb_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## duck
duck_hol <- data_wordcloud %>%
  filter(type == "object", object == "duck", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = duck_hol$value, freq = duck_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

duck_seq <- data_wordcloud %>%
  filter(type == "object", object == "duck", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = duck_seq$value, freq = duck_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## elephant
elephant_hol <- data_wordcloud %>%
  filter(type == "object", object == "elephant", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = elephant_hol$value, freq = elephant_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

elephant_seq <- data_wordcloud %>%
  filter(type == "object", object == "elephant", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = elephant_seq$value, freq = elephant_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## fork
fork_hol <- data_wordcloud %>%
  filter(type == "object", object == "fork", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = fork_hol$value, freq = fork_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

fork_seq <- data_wordcloud %>%
  filter(type == "object", object == "fork", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = fork_seq$value, freq = fork_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## hammer
hammer_hol <- data_wordcloud %>%
  filter(type == "object", object == "hammer", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = hammer_hol$value, freq = hammer_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

hammer_seq <- data_wordcloud %>%
  filter(type == "object", object == "hammer", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = hammer_seq$value, freq = hammer_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

## monkey
monkey_hol <- data_wordcloud %>%
  filter(type == "object", object == "monkey", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = monkey_hol$value, freq = monkey_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

monkey_seq <- data_wordcloud %>%
  filter(type == "object", object == "monkey", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = monkey_seq$value, freq = monkey_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))



```
```{r}
## par(mfrow=c(6,2))

# big
big_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "big", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = big_hol$value, freq = big_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

big_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "big", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = big_seq$value, freq = big_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


# jump
jump_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "jump", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = jump_hol$value, freq = jump_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

jump_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "jump", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = jump_seq$value, freq = jump_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

# many 
many_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "many", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = many_hol$value, freq = many_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

many_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "many", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = many_seq$value, freq = many_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

# one
one_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "one", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = one_hol$value, freq = one_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

one_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "one", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = one_seq$value, freq = one_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

# run
run_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "run", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = run_hol$value, freq = run_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

run_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "run", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = run_seq$value, freq = run_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

# small
small_hol <- data_wordcloud %>%
  filter(type == "feature", predicate == "small", condition == "hol") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = small_hol$value, freq = small_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

small_seq <- data_wordcloud %>%
  filter(type == "feature", predicate == "small", condition == "seq") %>%
  select(value, freq) %>%
  distinct() 

wordcloud(words = small_seq$value, freq = small_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


```



4.2. Wordclouds for objects (objects/animals) (sepearate for hol versus seq) (fÃ¼r jedes Objekt sepearat)
```{r}
## par(mfrow=c(2,2))

## object (hol vs seq)
object_hol <- data_wordcloud %>%
  filter(type == "object", class == "object", condition == "hol") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = object_hol$value, freq = object_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

object_seq <- data_wordcloud %>%
  filter(type == "object", class == "object", condition == "seq") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = object_seq$value, freq = object_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


## animal (hol vs seq)
animal_hol <- data_wordcloud %>%
  filter(type == "object", class == "animal", condition == "hol") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = animal_hol$value, freq = animal_hol$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

animal_seq <- data_wordcloud %>%
  filter(type == "object", class == "animal", condition == "seq") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = animal_seq$value, freq = animal_seq$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

```


4.3. wordclouds for features (movement/number/size) (sepearate for hol versus seq) (fÃ¼r jedes feature seperat, Rechtschreibung)
```{r}
## movement (hol vs seq)
movement_hol <- data_wordcloud %>%
  filter(type == "feature", property == "movement", condition == "hol") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = movement_hol$value, freq = movement_hol$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

movement_seq <- data_wordcloud %>%
  filter(type == "feature", property == "movement", condition == "seq") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = movement_seq$value, freq = movement_seq$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


## number (hol vs seq)
number_hol <- data_wordcloud %>%
  filter(type == "feature", property == "number", condition == "hol") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = number_hol$value, freq = number_hol$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

number_seq <- data_wordcloud %>%
  filter(type == "feature", property == "number", condition == "seq") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = number_seq$value, freq = number_seq$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))


## size (hol vs seq)
size_hol <- data_wordcloud %>%
  filter(type == "feature", property == "size", condition == "hol") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = size_hol$value, freq = size_hol$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

size_seq <- data_wordcloud %>%
  filter(type == "feature", property == "size", condition == "seq") %>%
  select(value, freq) %>%
  distinct()

wordcloud(words = size_seq$value, freq = size_seq$freq, min.freq = 1,
          random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))

```







(5. t-test + ANOVA) 

two.sided t.test (rel versus not) 

```{r}
## feature_str
t.test(feature_str ~ condition,
       alternative = c("two.sided"), data_rel_not)

## object_str
t.test(object_str ~ condition,
       alternative = c("two.sided"), data_rel_not)
```

```{r}
library("ez")

data_fea_contentANOVA <- data_fea_content %>%
  mutate(as.factor(predicate),
         as.factor(object),
         as.factor(condition)) %>%
  mutate(feature_str = ifelse(object_str == "rel", "2", "1"),
         as.numeric(feature_str)) %>%
  mutate(as.numeric(id))


ezANOVA_fea_content <- ezANOVA(data_fea_contentANOVA, dv=(feature_str), wid =(id),
                                   within =(condition), detailed = T,
                                   type=3)

ezAnova_PercCor <- ezANOVA(data_longPercCor, dv=.(Percent_Correct), wid=.(VPCode), 
                           between=.(Gruppe), within=.(Similarity, TestLanguage2), detailed = T, type=3)

```


